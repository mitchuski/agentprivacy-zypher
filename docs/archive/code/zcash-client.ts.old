/**
 * Zcash Client Module
 * Handles all interactions with Zebra (zebrad) full node for the Proverb Revelation Protocol
 * Updated to use Zebra - Zcash Foundation's Rust implementation (future-proof)
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs/promises';
import * as path from 'path';
import axios from 'axios';
import { config } from './config';
import logger from './logger';

const execAsync = promisify(exec);

// Types
export interface ZcashAddress {
  address: string;
  type: 'transparent' | 'shielded';
  balance: number;
}

export interface Transaction {
  txid: string;
  type: string;
  address: string;
  amount: number;
  memo?: string;
  confirmations: number;
  blockheight?: number;
  timestamp?: number;
}

export interface TransactionResult {
  txid: string;
  success: boolean;
  error?: string;
}

export interface ZcashConfig {
  network: 'mainnet' | 'testnet';
  rpcPort: number;
  rpcHost: string;
  rpcUrl?: string; // Optional: full RPC URL (for HTTP JSON-RPC)
  cookieFilePath?: string; // Path to Zebra cookie file (for authentication)
  timeout?: number;
}

export class ZcashClient {
  private config: ZcashConfig;
  private lastSyncHeight: number = 0;
  private syncInterval?: NodeJS.Timeout;

  constructor(customConfig?: Partial<ZcashConfig>) {
    // Use provided config or fall back to environment config
    const defaultConfig: ZcashConfig = {
      network: (config.zcash.network || 'mainnet') as 'mainnet' | 'testnet',
      rpcPort: config.zcash.rpcPort || (config.zcash.network === 'testnet' ? 18232 : 8232),
      rpcHost: config.zcash.rpcHost || '127.0.0.1',
      rpcUrl: config.zcash.rpcUrl,
      cookieFilePath: config.zcash.cookieFilePath,
      timeout: 30000
    };
    
    this.config = customConfig ? { ...defaultConfig, ...customConfig } : defaultConfig;
  }

  /**
   * Read authentication from Zebra cookie file
   * Cookie file format: username:password (single line)
   */
  private async readCookieFile(): Promise<{ username: string; password: string }> {
    let cookiePath: string;
    
    if (this.config.cookieFilePath) {
      cookiePath = this.config.cookieFilePath;
    } else {
      // Default cookie file location (Windows: AppData\Local\zebra\.cookie)
      if (process.platform === 'win32') {
        const localAppData = process.env.LOCALAPPDATA || path.join(process.env.USERPROFILE || '', 'AppData', 'Local');
        cookiePath = path.join(localAppData, 'zebra', '.cookie');
      } else {
        // Linux/macOS: ~/.zebra/.cookie or from config cookie_dir
        const homeDir = process.env.HOME || process.env.USERPROFILE || '';
        cookiePath = path.join(homeDir, '.zebra', '.cookie');
      }
    }
    
    try {
      const cookieContent = await fs.readFile(cookiePath, 'utf-8');
      const [username, password] = cookieContent.trim().split(':');
      
      if (!username || !password) {
        throw new Error('Invalid cookie file format. Expected: username:password');
      }
      
      logger.debug('Read cookie file', { path: cookiePath, username });
      return { username, password };
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        throw new Error(`Cookie file not found at ${cookiePath}. Make sure Zebra is running and has created the cookie file.`);
      }
      throw new Error(`Failed to read cookie file: ${error.message}`);
    }
  }

  /**
   * Execute a Zebra JSON-RPC command via HTTP
   * Uses cookie file authentication (Zebra default)
   */
  private async execCommand(rpcMethod: string, ...params: any[]): Promise<string> {
    const rpcUrl = this.config.rpcUrl || `http://${this.config.rpcHost}:${this.config.rpcPort}`;
    
    const requestBody = {
      jsonrpc: '2.0',
      id: Date.now(),
      method: rpcMethod,
      params: params
    };

    // Read authentication from cookie file
    const { username, password } = await this.readCookieFile();
    const auth = Buffer.from(`${username}:${password}`).toString('base64');

    try {
      logger.debug('Executing Zebra RPC command', { method: rpcMethod, params, url: rpcUrl });
      
      const response = await axios.post(rpcUrl, requestBody, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Basic ${auth}`
        },
        timeout: this.config.timeout || 30000,
        validateStatus: () => true // Don't throw on HTTP errors
      });

      if (response.status !== 200) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const result = response.data;
      
      if (result.error) {
        throw new Error(`RPC error: ${result.error.message || JSON.stringify(result.error)}`);
      }

      return JSON.stringify(result.result);
    } catch (error: any) {
      if (error.response) {
        logger.error('Zebra RPC failed', { 
          error: error.response.data || error.message, 
          method: rpcMethod,
          status: error.response.status
        });
        throw new Error(`Failed to execute Zebra RPC command: ${error.response.data?.error?.message || error.message}`);
      } else {
        logger.error('Zebra RPC failed', { error: error.message, method: rpcMethod });
        throw new Error(`Failed to execute Zebra RPC command: ${error.message}`);
      }
    }
  }

  /**
   * Execute a Zebra JSON-RPC command and parse JSON response
   */
  async execCommandJSON<T = any>(rpcMethod: string, ...params: any[]): Promise<T> {
    const output = await this.execCommand(rpcMethod, ...params);
    try {
      return JSON.parse(output) as T;
    } catch (error) {
      throw new Error(`Failed to parse JSON response: ${output}`);
    }
  }

  /**
   * Initialize the wallet and ensure Zebra is running and synced
   */
  async initialize(): Promise<void> {
    try {
      // Check if Zebra is running
      const info = await this.execCommandJSON('getinfo');
      logger.info('Connected to Zebra', { version: (info as any).version || 'unknown' });

      // Check sync status
      const blockchainInfo = await this.execCommandJSON('getblockchaininfo');
      const syncProgress = (blockchainInfo as any).verificationprogress;
      const blocks = (blockchainInfo as any).blocks;
      
      this.lastSyncHeight = blocks;
      
      if (syncProgress < 0.999) {
        logger.warn('Zebra node is still syncing', { 
          progress: (syncProgress * 100).toFixed(2) + '%',
          blocks 
        });
      } else {
        logger.info('Zebra node is fully synced', { blocks });
      }

      // Start background height check
      this.startBackgroundSync();
    } catch (error: any) {
      throw new Error(`Failed to initialize Zcash client: ${error.message}. Make sure Zebra (zebrad) is running.`);
    }
  }

  /**
   * Check sync status (zcashd syncs automatically)
   */
  async sync(): Promise<void> {
    try {
      const blockchainInfo = await this.execCommandJSON('getblockchaininfo');
      this.lastSyncHeight = (blockchainInfo as any).blocks;
    } catch (error: any) {
      throw new Error(`Sync check failed: ${error.message}`);
    }
  }

  /**
   * Start background sync check every 30 seconds
   */
  private startBackgroundSync(): void {
    this.syncInterval = setInterval(async () => {
      try {
        await this.sync();
      } catch (error) {
        logger.error('Background sync check error:', error);
      }
    }, 30000); // 30 seconds
  }

  /**
   * Stop background sync
   */
  stopBackgroundSync(): void {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
    }
  }

  /**
   * Get all addresses in the wallet
   */
  async getAddresses(): Promise<ZcashAddress[]> {
    try {
      const addresses: ZcashAddress[] = [];
      
      // Get transparent addresses
      const tAddresses = await this.execCommandJSON<string[]>('getaddressesbyaccount', '');
      for (const addr of tAddresses) {
        const balance = await this.getAddressBalance(addr);
        addresses.push({
          address: addr,
          type: 'transparent',
          balance
        });
      }
      
      // Get shielded addresses
      const zAddresses = await this.execCommandJSON<string[]>('z_listaddresses');
      for (const addr of zAddresses) {
        const balance = await this.getAddressBalance(addr);
        addresses.push({
          address: addr,
          type: 'shielded',
          balance
        });
      }
      
      return addresses;
    } catch (error: any) {
      throw new Error(`Failed to get addresses: ${error.message}`);
    }
  }

  /**
   * Get balance for a specific address
   */
  private async getAddressBalance(address: string): Promise<number> {
    try {
      if (address.startsWith('t') || address.startsWith('tm')) {
        // Transparent address
        const unspent = await this.execCommandJSON<any[]>('listunspent', 0, 9999999, [address]);
        return unspent.reduce((sum, utxo) => sum + utxo.amount, 0);
      } else {
        // Shielded address - use z_getbalance
        const balance = await this.execCommandJSON<number>('z_getbalance', address);
        return balance || 0;
      }
    } catch {
      return 0;
    }
  }

  /**
   * Get the primary transparent address (for public inscriptions)
   * Creates a new one if none exists
   */
  async getTransparentAddress(): Promise<string> {
    try {
      const addresses = await this.execCommandJSON<string[]>('getaddressesbyaccount', '');
      if (addresses.length > 0) {
        return addresses[0];
      }
      // Create new address if none exists
      return await this.execCommandJSON<string>('getnewaddress');
    } catch (error: any) {
      throw new Error(`Failed to get transparent address: ${error.message}`);
    }
  }

  /**
   * Get the primary shielded address (for receiving initial submissions + private pool)
   * Creates a new one if none exists
   */
  async getShieldedAddress(): Promise<string> {
    try {
      const addresses = await this.execCommandJSON<string[]>('z_listaddresses');
      if (addresses.length > 0) {
        return addresses[0];
      }
      // Create new shielded address if none exists
      return await this.execCommandJSON<string>('z_getnewaddress');
    } catch (error: any) {
      throw new Error(`Failed to get shielded address: ${error.message}`);
    }
  }

  /**
   * Get wallet balance
   */
  async getBalance(): Promise<{ transparent: number; shielded: number; total: number }> {
    try {
      // Get transparent balance
      const transparent = await this.execCommandJSON<number>('getbalance');
      
      // Get shielded balance (sum of all shielded addresses)
      const zAddresses = await this.execCommandJSON<string[]>('z_listaddresses');
      let shielded = 0;
      for (const addr of zAddresses) {
        const balance = await this.execCommandJSON<number>('z_getbalance', addr);
        shielded += balance || 0;
      }
      
      return {
        transparent: transparent || 0,
        shielded: shielded,
        total: (transparent || 0) + shielded
      };
    } catch (error: any) {
      throw new Error(`Failed to get balance: ${error.message}`);
    }
  }

  /**
   * List recent transactions
   */
  async listTransactions(count: number = 50): Promise<Transaction[]> {
    try {
      const txList = await this.execCommandJSON<any[]>('listtransactions', '*', count);
      const transactions: Transaction[] = [];
      
      for (const tx of txList) {
        // Get transaction details
        const txDetails = await this.execCommandJSON<any>('gettransaction', tx.txid);
        
        // Determine type
        const type = tx.amount > 0 ? 'incoming' : 'outgoing';
        
        // Extract memo if present (for shielded transactions)
        let memo: string | undefined;
        if (txDetails.vjoinsplit && txDetails.vjoinsplit.length > 0) {
          // Try to extract memo from vjoinsplit
          for (const js of txDetails.vjoinsplit) {
            if (js.memo) {
              memo = Buffer.from(js.memo, 'hex').toString('utf8').replace(/\0/g, '').trim();
              if (memo) break;
            }
          }
        }
        
        transactions.push({
          txid: tx.txid,
          type: type,
          address: tx.address || '',
          amount: Math.abs(tx.amount),
          memo: memo,
          confirmations: tx.confirmations || 0,
          blockheight: tx.blockheight,
          timestamp: tx.time
        });
      }
      
      return transactions;
    } catch (error: any) {
      throw new Error(`Failed to list transactions: ${error.message}`);
    }
  }

  /**
   * Get new transactions since last check
   * Filters for incoming transactions with memos
   * 
   * NOTE: Works for both transparent and shielded transactions.
   * zecwallet-cli automatically decrypts memos for shielded transactions
   * (wallet has viewing key), so memos are available as plain text.
   */
  async getNewSubmissions(lastCheckedHeight?: number): Promise<Transaction[]> {
    try {
      const allTransactions = await this.listTransactions(100);
      
      // Filter for incoming transactions with memos
      // This includes both transparent (t→t) and shielded (z→z) transactions
      // For shielded transactions, memos are automatically decrypted by zecwallet-cli
      const submissions = allTransactions.filter(tx => 
        tx.type === 'incoming' &&
        tx.memo &&
        tx.memo.length > 0 &&
        tx.confirmations >= 1 // At least 1 confirmation
      );
      
      // If we have a last checked height, filter by that
      if (lastCheckedHeight) {
        return submissions.filter(tx => 
          tx.blockheight && tx.blockheight > lastCheckedHeight
        );
      }
      
      return submissions;
    } catch (error: any) {
      throw new Error(`Failed to get new submissions: ${error.message}`);
    }
  }

  /**
   * Send a transaction with memo
   * Used for inscriptions
   */
  async send(
    toAddress: string,
    amount: number,
    memo?: string
  ): Promise<TransactionResult> {
    try {
      let txid: string;
      
      if (toAddress.startsWith('t') || toAddress.startsWith('tm')) {
        // Transparent address
        if (memo) {
          // For transparent addresses, memo goes in OP_RETURN
          // Use sendtoaddress for transparent (memos not directly supported, would need raw transaction)
          txid = await this.execCommandJSON<string>('sendtoaddress', toAddress, amount);
        } else {
          txid = await this.execCommandJSON<string>('sendtoaddress', toAddress, amount);
        }
      } else {
        // Shielded address - use z_sendmany with memo
        const fromAddress = await this.getShieldedAddress();
        const recipients = [{
          address: toAddress,
          amount: amount,
          memo: memo ? Buffer.from(memo, 'utf8').toString('hex').padEnd(512, '0') : undefined
        }];
        
        const opid = await this.execCommandJSON<string>('z_sendmany', fromAddress, JSON.stringify(recipients));
        
        // Wait for operation to complete
        let status;
        let attempts = 0;
        do {
          await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds
          status = await this.execCommandJSON<any>('z_getoperationstatus', JSON.stringify([opid]));
          attempts++;
          if (attempts > 30) throw new Error('Transaction timeout');
        } while (status[0].status === 'executing' || status[0].status === 'queued');
        
        if (status[0].status !== 'success') {
          throw new Error(`Transaction failed: ${status[0].error?.message || 'Unknown error'}`);
        }
        
        txid = status[0].result.txid;
      }
      
      logger.info('Transaction sent', { to: toAddress, amount, txid });
      
      return {
        txid: txid,
        success: true
      };
    } catch (error: any) {
      logger.error('Transaction send failed', { error: error.message, to: toAddress, amount });
      return {
        txid: '',
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Legacy method for compatibility
   */
  async sendTransaction(
    to: string,
    amount: number,
    memo?: string
  ): Promise<string> {
    const result = await this.send(to, amount, memo);
    if (!result.success) {
      throw new Error(result.error || 'Transaction failed');
    }
    return result.txid;
  }

  /**
   * Get new transactions since last check (legacy method)
   */
  async getNewTransactions(lastHeight: number): Promise<Transaction[]> {
    return this.getNewSubmissions(lastHeight);
  }

  /**
   * Get current block height
   */
  async getBlockHeight(): Promise<number> {
    const blockchainInfo = await this.execCommandJSON<any>('getblockchaininfo');
    const height = blockchainInfo.blocks;
    this.lastSyncHeight = height;
    return height;
  }

  /**
   * Get current sync height
   */
  getCurrentHeight(): number {
    return this.lastSyncHeight;
  }

  /**
   * Validate Zcash address
   */
  validateAddress(address: string): { valid: boolean; type?: 'transparent' | 'shielded' } {
    // Transparent address (testnet: tm*, mainnet: t1*)
    if (address.match(/^t[m1][a-zA-Z0-9]{33}$/)) {
      return { valid: true, type: 'transparent' };
    }
    
    // Shielded address (Sapling: zs*)
    if (address.match(/^zs[a-z0-9]{76}$/)) {
      return { valid: true, type: 'shielded' };
    }
    
    return { valid: false };
  }

  /**
   * Export wallet backup
   * Note: Zebra may handle wallet backup differently - check Zebra documentation
   */
  async exportBackup(outputPath: string): Promise<void> {
    try {
      // Try backupwallet command (if supported by Zebra)
      await this.execCommand('backupwallet', outputPath);
      logger.info('Wallet backed up', { path: outputPath });
    } catch (error: any) {
      // If backupwallet not supported, log warning
      logger.warn('Wallet backup command not available', { 
        error: error.message,
        note: 'Zebra may use different backup mechanisms - check Zebra documentation'
      });
      throw new Error(`Failed to export backup: ${error.message}`);
    }
  }

  /**
   * Cleanup resources
   */
  async cleanup(): Promise<void> {
    this.stopBackgroundSync();
  }
}

/**
 * Create Zcash client from environment
 */
export function createZcashClient(): ZcashClient {
  return new ZcashClient();
}

// Export singleton instance for backward compatibility
export const zcashClient = createZcashClient();

